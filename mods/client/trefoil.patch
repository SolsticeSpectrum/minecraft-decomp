--- a/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -67,17 +67,8 @@
     }

     private static Aquifer.FluidPicker createFluidPicker(final NoiseGeneratorSettings settings) {
-        Aquifer.FluidStatus lavaStatus = new Aquifer.FluidStatus(-54, Blocks.LAVA.defaultBlockState());
-        int seaLevel = settings.seaLevel();
-        Aquifer.FluidStatus seaStatus = new Aquifer.FluidStatus(seaLevel, settings.defaultFluid());
         Aquifer.FluidStatus emptyStatus = new Aquifer.FluidStatus(DimensionType.MIN_Y * 2, Blocks.AIR.defaultBlockState());
-        return (x, y, z) -> {
-            if (SharedConstants.DEBUG_DISABLE_FLUID_GENERATION) {
-                return emptyStatus;
-            } else {
-                return y < Math.min(-54, seaLevel) ? lavaStatus : seaStatus;
-            }
-        };
+        return (x, y, z) -> emptyStatus;
     }

     @Override
--- a/net/minecraft/world/level/levelgen/DensityFunctions.java
+++ b/net/minecraft/world/level/levelgen/DensityFunctions.java
@@ -72,6 +72,7 @@
         register(registry, "spline", DensityFunctions.Spline.CODEC);
         register(registry, "constant", DensityFunctions.Constant.CODEC);
         register(registry, "y_clamped_gradient", DensityFunctions.YClampedGradient.CODEC);
+        register(registry, "trefoil", DensityFunctions.Trefoil.CODEC);
         return register(registry, "find_top_surface", DensityFunctions.FindTopSurface.CODEC);
     }

@@ -280,6 +281,10 @@
         return new DensityFunctions.FindTopSurface(density, upperBound, lowerBound, stepSize);
     }

+    public static DensityFunction trefoil(final int scale, final int thick, final int gap) {
+        return new DensityFunctions.Trefoil(scale, thick, gap);
+    }
+
     private record Ap2(
         DensityFunctions.TwoArgumentSimpleFunction.Type type, DensityFunction argument1, DensityFunction argument2, double minValue, double maxValue
     ) implements DensityFunctions.TwoArgumentSimpleFunction {
@@ -1391,6 +1396,62 @@
         }
     }

+    protected record Trefoil(int scale, int thick, int gap) implements DensityFunction.SimpleFunction {
+        private static final MapCodec<DensityFunctions.Trefoil> DATA_CODEC = RecordCodecBuilder.mapCodec(
+            i -> i.group(
+                    Codec.INT.fieldOf("scale").forGetter(DensityFunctions.Trefoil::scale),
+                    Codec.INT.fieldOf("thick").forGetter(DensityFunctions.Trefoil::thick),
+                    Codec.INT.fieldOf("gap").forGetter(DensityFunctions.Trefoil::gap)
+                )
+                .apply(i, DensityFunctions.Trefoil::new)
+        );
+        public static final KeyDispatchDataCodec<DensityFunctions.Trefoil> CODEC = DensityFunctions.makeCodec(DATA_CODEC);
+        private static final java.util.Map<Long, java.util.Set<Long>> CACHE = new java.util.concurrent.ConcurrentHashMap<>();
+
+        private static long key(final int s, final int t) {
+            return ((long) s << 32) | (t & 0xFFFFFFFFL);
+        }
+
+        private static long pack(final int x, final int y, final int z) {
+            return ((long) (x + 128) << 16) | ((long) (y + 128) << 8) | (z + 128);
+        }
+
+        private java.util.Set<Long> shape() {
+            return CACHE.computeIfAbsent(key(this.scale, this.thick), k -> build(this.scale, this.thick));
+        }
+
+        private static java.util.Set<Long> build(final int scale, final int thick) {
+            java.util.Set<Long> out = new java.util.HashSet<>();
+            int n = 512, rr = thick * thick, b = 3 * scale + thick;
+            for (int x = -b; x <= b; x++) {
+                for (int y = -scale - thick; y <= scale + thick; y++) {
+                    for (int z = -b; z <= b; z++) {
+                        double min = Double.MAX_VALUE;
+                        for (int i = 0; i < n; i++) {
+                            double t = (i * 2.0 * Math.PI) / n;
+                            double a = 2.0 + Math.cos(3.0 * t);
+                            double kx = a * Math.cos(2.0 * t) * scale, ky = Math.sin(3.0 * t) * scale, kz = a * Math.sin(2.0 * t) * scale;
+                            double dx = x - kx, dy = y - ky, dz = z - kz;
+                            double d = dx * dx + dy * dy + dz * dz;
+                            if (d < min) min = d;
+                        }
+                        if (min <= rr) out.add(pack(x, y, z));
+                    }
+                }
+            }
+            return out;
+        }
+
+        @Override
+        public double compute(final DensityFunction.FunctionContext ctx) {
+            int x = ctx.blockX(), y = ctx.blockY(), z = ctx.blockZ();
+            int cx = Math.floorDiv(x, this.gap) * this.gap + this.gap / 2;
+            int cy = Math.floorDiv(y, this.gap) * this.gap + this.gap / 2;
+            int cz = Math.floorDiv(z, this.gap) * this.gap + this.gap / 2;
+            int rx = x - cx, ry = y - cy, rz = z - cz;
+            return shape().contains(pack(rx, ry, rz)) ? 1.0 : -1.0;
+        }
+
+        @Override
+        public double minValue() { return -1.0; }
+
+        @Override
+        public double maxValue() { return 1.0; }
+
+        @Override
+        public KeyDispatchDataCodec<? extends DensityFunction> codec() { return CODEC; }
+    }
+
     private record YClampedGradient(int fromY, int toY, double fromValue, double toValue) implements DensityFunction.SimpleFunction {
         private static final MapCodec<DensityFunctions.YClampedGradient> DATA_CODEC = RecordCodecBuilder.mapCodec(
             i -> i.group(
--- a/net/minecraft/world/level/levelgen/RandomState.java
+++ b/net/minecraft/world/level/levelgen/RandomState.java
@@ -94,7 +94,8 @@
             }
         }

-        this.router = settings.noiseRouter().mapAll(new NoiseWiringHelper());
+        NoiseRouter base = settings.noiseRouter().mapAll(new NoiseWiringHelper());
+        this.router = wrap(base);
         DensityFunction.Visitor noiseFlattener = new DensityFunction.Visitor() {
             private final Map<DensityFunction, DensityFunction> wrapped = new HashMap<>();

@@ -149,4 +150,14 @@
     public PositionalRandomFactory oreRandom() {
         return this.oreRandom;
     }
+
+    private static NoiseRouter wrap(final NoiseRouter r) {
+        DensityFunction shape = DensityFunctions.trefoil(20, 6, 160);
+        DensityFunction empty = DensityFunctions.constant(-1.0);
+        return new NoiseRouter(
+            r.barrierNoise(), empty, empty, empty,
+            r.temperature(), r.vegetation(), r.continents(), r.erosion(), r.depth(), r.ridges(),
+            empty, shape, empty, empty, empty
+        );
+    }
 }
